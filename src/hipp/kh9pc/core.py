"""
Copyright (c) 2025 HIPP developers
Description: core functions for the preprocessing of KH-9 PC images
"""

import glob
import os
import subprocess
from pathlib import Path
from typing import Any

# import pyvips
from hipp.image import warp_raster_pixels
from hipp.kh9pc.lines_processing import (
    compute_transformation,
    detect_horizontal_collimation_lines,
    detect_vertical_edges,
    plot_distance_between_collimation_lines,
)

####################################################################################################################################
#                                                   MAIN FUNCTIONS
####################################################################################################################################


def image_mosaic(
    image_paths: list[str],
    output_image_path: str,
    overwrite: bool = False,
    threads: int = 0,
    cleanup: bool = True,
    verbose: bool = True,
    dryrun: bool = False,
) -> None:
    """
    Mosaics a list of images into a single output image using the external 'image_mosaic' command.

    Parameters:
        image_paths (list[str]): List of paths to input image tiles.
        output_image_path (str): Path to the output mosaic image.
        overwrite (bool): If False and the output file exists, the function will skip processing. Default is False.
        threads (int): Number of threads to use for processing. Default is 0 (let the tool decide).
        cleanup (bool): Whether to remove temporary log and auxiliary files after processing. Default is True.
        verbose (bool): If True, prints detailed progress and command information. Default is True.
        dryrun (bool): If True, builds the command but does not execute it. Useful for debugging. Default is False.

    Returns:
        None
    """
    # Skip processing if the output exists and overwriting is disabled
    if os.path.exists(output_image_path) and not overwrite:
        if verbose:
            print(f"Skipping {output_image_path}: output already exists")
        return

    if verbose:
        print(f"\nMosaicking {output_image_path} with {len(image_paths)} tiles...\n")

    # Build the command for the external 'image_mosaic' tool
    cmd = [
        "image_mosaic",
        *image_paths,
        "--ot",
        "byte",
        "--overlap-width",
        "3000",
        "--threads",
        str(threads),
        "-o",
        output_image_path,
    ]

    # Display the constructed command
    if verbose:
        print(" ".join(cmd))

    # Execute the command unless in dry run mode
    if not dryrun:
        try:
            subprocess.run(
                cmd,
                check=True,
                stdout=None if verbose else subprocess.DEVNULL,
                stderr=None if verbose else subprocess.DEVNULL,
            )
        except subprocess.CalledProcessError as e:
            print(f"Error while processing {output_image_path}: {e}")

    # Optionally remove temporary log and auxiliary files generated by the tool
    if cleanup:
        for f in glob.glob(f"{output_image_path}-log-image_mosaic-*.txt") + glob.glob(f"{output_image_path}.aux.xml"):
            os.remove(f)


def collimation_rectification(
    input_raster_path: str | Path,
    output_raster_path: str | Path,
    qc_dir: str | Path,
    collimation_lines_detection_kwargs: dict[str, Any] | None = None,
    vertical_edges_detection_kwargs: dict[str, Any] | None = None,
    transformation_kwargs: dict[str, Any] | None = None,
    verbose: bool = True,
    max_workers: int = 4,
) -> None:
    """
    Perform geometric rectification of a raster based on collimation line detection.

    This function detects horizontal and vertical collimation lines in a raster image,
    computes the geometric transformation required to correct optical or alignment
    distortions, and warps the image accordingly. It also generates quality control (QC)
    plots showing detected features and line spacing before and after rectification.

    The process includes:
      1. Detection of horizontal collimation lines.
      2. Detection of vertical edges.
      3. Estimation and application of the transformation matrix.
      4. Post-rectification evaluation and visualization.

    Parameters
    ----------
    input_raster_path : str or Path
        Path to the input raster to be rectified.
    output_raster_path : str or Path
        Path where the rectified raster will be saved.
    qc_dir : str or Path
        Directory where quality control (QC) plots and diagnostics will be saved.
    collimation_lines_detection_kwargs : dict, optional
        Additional keyword arguments passed to `detect_horizontal_collimation_lines()`.
    vertical_edges_detection_kwargs : dict, optional
        Additional keyword arguments passed to `detect_vertical_edges()`.
    transformation_kwargs : dict, optional
        Additional keyword arguments passed to `compute_transformation()`.
    verbose : bool, optional
        If True, prints progress messages to the console. Default is True.
    max_workers : int, optional
        Number of parallel workers to use during image warping. Default is 4.

    Returns
    -------
    None
        The function writes the rectified raster and several QC plots to disk.

    Raises
    ------
    FileNotFoundError
        If the input raster file does not exist.
    ValueError
        If the detected collimation lines or transformation parameters are invalid.
    RuntimeError
        If the rectification process fails during warping or transformation.

    Notes
    -----
    - The function assumes that the input raster contains visible collimation lines
      that can be automatically detected.
    - QC plots are saved in structured subdirectories under `qc_dir` for traceability.
    - Warping uses bicubic interpolation for smooth results.
    - Padding is set to zero after rectification because the output image is cropped.

    Example
    -------
    >>> collimation_rectification(
    ...     input_raster_path="raw/camera_image.tif",
    ...     output_raster_path="rectified/camera_image_rectified.tif",
    ...     qc_dir="qc_results/",
    ...     collimation_lines_detection_kwargs={"sigma": 2.0},
    ...     transformation_kwargs={"method": "affine"},
    ...     verbose=True,
    ...     max_workers=8
    ... )
    Collimation rectification for camera_image.tif :
        -[1/4] Estimation of collimation lines...
        -[2/4] Detection of vertical lines...
        -[3/4] Warping image (can take some times)...
        -[4/4] Estimation of collimation lines after transformation...
    """
    # transform to Path every paths
    input_raster_path = Path(input_raster_path)
    output_raster_path = Path(output_raster_path)
    qc_dir = Path(qc_dir)

    # transform none kwargs to empty dict
    collimation_lines_detection_kwargs = collimation_lines_detection_kwargs or {}
    vertical_edges_detection_kwargs = vertical_edges_detection_kwargs or {}
    transformation_kwargs = transformation_kwargs or {}

    if verbose:
        print(f"Collimation rectification for {input_raster_path.name} : ")

    # Detect collimation lines
    if verbose:
        print("\t-[1/4] Estimation of collimation lines...")
    collimation_lines = detect_horizontal_collimation_lines(
        input_raster_path,
        plot=False,
        output_plot_path=qc_dir / "collimation_lines" / f"{input_raster_path.stem}.png",
        **collimation_lines_detection_kwargs,
    )

    # Detect vertical lines
    if verbose:
        print("\t-[2/4] Detection of vertical lines...")
    vertical_edges = detect_vertical_edges(
        input_raster_path,
        plot=False,
        output_plot_path=qc_dir / "vertical_edges" / f"{input_raster_path.stem}.png",
        **vertical_edges_detection_kwargs,
    )

    # Plot the distance between collimation lines for quality control
    plot_distance_between_collimation_lines(
        vertical_edges,
        collimation_lines,
        plot=False,
        output_plot_path=qc_dir / "distance_between_collimation_lines" / f"{input_raster_path.stem}.png",
    )

    # compute the transformation and plot the transformation plot
    tf_matrix, output_img_size, _ = compute_transformation(
        vertical_edges,
        collimation_lines,
        plot=False,
        output_plot_path=qc_dir / "transformations" / f"{input_raster_path.stem}.png",
        **transformation_kwargs,
    )

    # warp the image with the previously computed transformation (use bicubic interpolation)
    if verbose:
        print("\t-[3/4] Warping image (can take some times)...")
    warp_raster_pixels(input_raster_path, output_raster_path, tf_matrix, output_img_size, max_workers)

    # detect collimation lines after the transformation
    if verbose:
        print("\t-[4/4] Estimation of collimation lines after transformation...")

    # set the padding to (0,0) because the output image is cropped
    kwargs = collimation_lines_detection_kwargs.copy()
    kwargs.update({"padding_dict": {"top": (0, 0), "bottom": (0, 0)}})

    collimation_lines_after_transform = detect_horizontal_collimation_lines(
        output_raster_path,
        plot=False,
        output_plot_path=qc_dir / "collimation_lines_after_transform" / f"{input_raster_path.stem}.png",
        **kwargs,
    )

    # Plot the distance between collimation lines after transformation
    new_vertical_edges = {"left": 0, "right": output_img_size[0]}
    plot_distance_between_collimation_lines(
        new_vertical_edges,
        collimation_lines_after_transform,
        plot=False,
        output_plot_path=qc_dir
        / "distance_between_collimation_lines_after_transform"
        / f"{input_raster_path.stem}.png",
    )


####################################################################################################################################
#                                                   PRIVATE FUNCTIONS
####################################################################################################################################
