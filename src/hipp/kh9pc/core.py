"""
Copyright (c) 2025 HIPP developers
Description: core functions for the preprocessing of KH-9 PC images
"""

import glob
import os
import subprocess
from pathlib import Path

import joblib
from skimage.transform import AffineTransform, ThinPlateSplineTransform

# import pyvips
from hipp.image import remap_tif_blockwise
from hipp.kh9pc.collimation_lines import (
    compute_source_and_target_grid,
    detect_collimation_lines,
    detect_vertical_edges,
)
from hipp.kh9pc.quality_control import (
    plot_collimation_gradient,
    plot_distance_between_collimation_lines,
    plot_src_and_dst_points,
)

####################################################################################################################################
#                                                   MAIN FUNCTIONS
####################################################################################################################################


def image_mosaic(
    image_paths: list[str],
    output_image_path: str,
    overwrite: bool = False,
    threads: int = 0,
    cleanup: bool = True,
    verbose: bool = True,
    dryrun: bool = False,
) -> None:
    """
    Mosaics a list of images into a single output image using the external 'image_mosaic' command.

    Parameters:
        image_paths (list[str]): List of paths to input image tiles.
        output_image_path (str): Path to the output mosaic image.
        overwrite (bool): If False and the output file exists, the function will skip processing. Default is False.
        threads (int): Number of threads to use for processing. Default is 0 (let the tool decide).
        cleanup (bool): Whether to remove temporary log and auxiliary files after processing. Default is True.
        verbose (bool): If True, prints detailed progress and command information. Default is True.
        dryrun (bool): If True, builds the command but does not execute it. Useful for debugging. Default is False.

    Returns:
        None
    """
    # Skip processing if the output exists and overwriting is disabled
    if os.path.exists(output_image_path) and not overwrite:
        if verbose:
            print(f"Skipping {output_image_path}: output already exists")
        return

    if verbose:
        print(f"\nMosaicking {output_image_path} with {len(image_paths)} tiles...\n")

    # Build the command for the external 'image_mosaic' tool
    cmd = [
        "image_mosaic",
        *image_paths,
        "--ot",
        "byte",
        "--overlap-width",
        "3000",
        "--threads",
        str(threads),
        "-o",
        output_image_path,
    ]

    # Display the constructed command
    if verbose:
        print(" ".join(cmd))

    # Execute the command unless in dry run mode
    if not dryrun:
        try:
            subprocess.run(
                cmd,
                check=True,
                stdout=None if verbose else subprocess.DEVNULL,
                stderr=None if verbose else subprocess.DEVNULL,
            )
        except subprocess.CalledProcessError as e:
            print(f"Error while processing {output_image_path}: {e}")

    # Optionally remove temporary log and auxiliary files generated by the tool
    if cleanup:
        for f in glob.glob(f"{output_image_path}-log-image_mosaic-*.txt") + glob.glob(f"{output_image_path}.aux.xml"):
            os.remove(f)


def collimation_rectification(
    input_raster_path: str | Path,
    output_raster_path: str | Path,
    qc_dir: str | Path,
    bg_px_threshold: int = 20,
    collimation_line_dist: int = 21770,
    transformation: str = "tps",
    verbose: bool = True,
) -> None:
    """
    Perform collimation rectification on a raster image using a geometric transformation
    (Thin Plate Spline or Affine warping).

    This function detects the horizontal and vertical collimation features in a raster image,
    estimates the geometric deformation, and rectifies the image by applying an inverse
    geometric transformation. The user can choose between a Thin Plate Spline (TPS) or
    Affine transformation model. It also produces several quality control (QC) plots
    illustrating each processing step, including line detection, distance consistency,
    and transformation effects.

    Args:
        input_raster_path (str | Path):
            Path to the input raster image to be rectified.
        output_raster_path (str | Path):
            Path where the geometrically rectified image will be saved.
        qc_dir (str | Path):
            Directory where quality control plots and intermediate data will be stored.
        bg_px_threshold (int, optional):
            Minimum pixel intensity difference used to detect vertical edges. Defaults to 20.
        collimation_line_dist (int, optional):
            Expected distance (in pixels) between the top and bottom collimation lines
            in the rectified image. Defaults to 21770.
        transformation (str, optional):
            Type of geometric transformation to apply.
            - "tps": Thin Plate Spline (non-linear, smooth correction)
            - "affine": Affine (linear correction)
            Defaults to "tps".
        verbose (bool, optional):
            If True, prints progress updates during processing. Defaults to True.

    Returns:
        None

    Workflow:
        1. Detect top and bottom collimation lines using RANSAC polynomial fitting.
        2. Detect left and right vertical edges using robust RANSAC regression.
        3. Estimate and plot the distance between the detected collimation lines.
        4. Compute source and destination grids from detected features.
        5. Estimate the chosen transformation model (TPS or Affine).
        6. Apply the inverse transformation to rectify the image geometry.
        7. Re-detect collimation lines after transformation for validation.
        8. Generate and save all QC plots (line detection, distances, gradients).

    Notes:
        - The function assumes that the raster image contains clear collimation marks.
        - All intermediate QC results are saved to `qc_dir` for traceability.
        - The transformation preserves image size consistency using the computed `output_size`.
        - The Thin Plate Spline model provides a smooth, non-linear geometric correction,
          while the Affine model applies a simpler linear correction.

    Example:
        >>> collimation_rectification(
        ...     input_raster_path="raw_scene.tif",
        ...     output_raster_path="rectified_scene.tif",
        ...     qc_dir="quality_control/",
        ...     bg_px_threshold=25,
        ...     collimation_line_dist=21800,
        ...     transformation="affine",
        ...     verbose=True
        ... )
    """
    # transform to Path every paths
    input_raster_path = Path(input_raster_path)
    output_raster_path = Path(output_raster_path)
    qc_dir = Path(qc_dir)
    data_dir = qc_dir / "data" / input_raster_path.stem
    data_dir.mkdir(exist_ok=True, parents=True)

    if verbose:
        print(f"Collimation rectification for {input_raster_path.name} : ")

    # Detect collimation lines
    if verbose:
        print("\t-[1/4] Estimation of collimation lines...")
    collimation_lines = detect_collimation_lines(
        input_raster_path,
        plot=False,
        output_plot_path=qc_dir / "collimation_lines" / f"{input_raster_path.stem}.png",
    )
    joblib.dump(collimation_lines, data_dir / "collimation_lines.pkl")

    # Detect vertical lines
    if verbose:
        print("\t-[2/4] Detection of vertical lines...")
    vertical_edges = detect_vertical_edges(
        input_raster_path,
        bg_px_threshold,
        plot=False,
        output_plot_path=qc_dir / "vertical_edges" / f"{input_raster_path.stem}.png",
    )
    joblib.dump(vertical_edges, data_dir / "vertical_edges.pkl")

    # make the source and destination points
    src_grid, dst_grid, output_size = compute_source_and_target_grid(
        vertical_edges, collimation_lines, collimation_line_dist
    )
    joblib.dump(src_grid, data_dir / "src_grid.pkl")
    joblib.dump(src_grid, data_dir / "dst_grid.pkl")

    src_points = src_grid.reshape(-1, 2)
    dst_points = dst_grid.reshape(-1, 2)

    # plot them for quality control
    plot_src_and_dst_points(
        src_points,
        dst_points,
        output_size,
        plot=False,
        output_plot_path=qc_dir / "transformations" / f"{input_raster_path.stem}.png",
    )

    # choose the goood tranformation and set some hyperparamters
    inverse_remap: ThinPlateSplineTransform | AffineTransform
    if transformation == "tps":
        inverse_remap = ThinPlateSplineTransform()
        lowres_step = 100
        block_size = 2**13
    elif transformation == "affine":
        inverse_remap = AffineTransform()
        lowres_step = None
        block_size = 256
    else:
        raise ValueError(f"{transformation} not supported, support only 'tps' and 'affine'")

    # for remapping the hipp.image.remap_tif_blockwise use the inverse transformation function
    # so we estimate our transformation with dst -> src
    inverse_remap.estimate(dst_points, src_points)

    # remap the image with the previously computed function inverse_remap_function
    if verbose:
        print("\t-[3/4] Warping image (can take some times)...")
    remap_tif_blockwise(
        input_raster_path,
        output_raster_path,
        inverse_remap,
        output_size,
        block_size=block_size,
        pbar_desc=f"{input_raster_path.name} remapping",
        lowres_step=lowres_step,
    )

    # detect collimation lines after the transformation
    if verbose:
        print("\t-[4/4] Estimation of collimation lines after transformation...")

    collimation_lines_after_transform = detect_collimation_lines(
        output_raster_path,
        0.05,
        plot=False,
        output_plot_path=qc_dir / "collimation_lines_after_transform" / f"{input_raster_path.stem}.png",
    )
    joblib.dump(collimation_lines_after_transform, data_dir / "collimation_lines_after_transform.pkl")

    # Plot the distance between collimation lines for quality control
    plot_distance_between_collimation_lines(
        collimation_lines,
        collimation_lines_after_transform,
        output_size[0],
        collimation_line_dist,
        plot=False,
        output_plot_path=qc_dir / "distance_between_collimation_lines" / f"{input_raster_path.stem}.png",
    )

    # plot both collimation gradient before and after transform
    plot_collimation_gradient(
        collimation_lines,
        collimation_lines_after_transform,
        output_size[0],
        plot=False,
        output_plot_path=qc_dir / "collimation_gradients" / f"{input_raster_path.stem}.png",
    )


####################################################################################################################################
#                                                   PRIVATE FUNCTIONS
####################################################################################################################################
