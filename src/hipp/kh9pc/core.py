"""
Copyright (c) 2025 HIPP developers
Description: core functions for the preprocessing of KH-9 PC images
"""

import glob
import os
import subprocess
from pathlib import Path

# import pyvips
from hipp.image import remap_tif_blockwise
from hipp.kh9pc.collimation_lines import (
    detect_collimation_lines,
    detect_vertical_edges,
    make_inverse_tps_function,
    make_tps_points,
)
from hipp.kh9pc.quality_control import (
    plot_collimation_gradient,
    plot_distance_between_collimation_lines,
    plot_tps_points,
)

####################################################################################################################################
#                                                   MAIN FUNCTIONS
####################################################################################################################################


def image_mosaic(
    image_paths: list[str],
    output_image_path: str,
    overwrite: bool = False,
    threads: int = 0,
    cleanup: bool = True,
    verbose: bool = True,
    dryrun: bool = False,
) -> None:
    """
    Mosaics a list of images into a single output image using the external 'image_mosaic' command.

    Parameters:
        image_paths (list[str]): List of paths to input image tiles.
        output_image_path (str): Path to the output mosaic image.
        overwrite (bool): If False and the output file exists, the function will skip processing. Default is False.
        threads (int): Number of threads to use for processing. Default is 0 (let the tool decide).
        cleanup (bool): Whether to remove temporary log and auxiliary files after processing. Default is True.
        verbose (bool): If True, prints detailed progress and command information. Default is True.
        dryrun (bool): If True, builds the command but does not execute it. Useful for debugging. Default is False.

    Returns:
        None
    """
    # Skip processing if the output exists and overwriting is disabled
    if os.path.exists(output_image_path) and not overwrite:
        if verbose:
            print(f"Skipping {output_image_path}: output already exists")
        return

    if verbose:
        print(f"\nMosaicking {output_image_path} with {len(image_paths)} tiles...\n")

    # Build the command for the external 'image_mosaic' tool
    cmd = [
        "image_mosaic",
        *image_paths,
        "--ot",
        "byte",
        "--overlap-width",
        "3000",
        "--threads",
        str(threads),
        "-o",
        output_image_path,
    ]

    # Display the constructed command
    if verbose:
        print(" ".join(cmd))

    # Execute the command unless in dry run mode
    if not dryrun:
        try:
            subprocess.run(
                cmd,
                check=True,
                stdout=None if verbose else subprocess.DEVNULL,
                stderr=None if verbose else subprocess.DEVNULL,
            )
        except subprocess.CalledProcessError as e:
            print(f"Error while processing {output_image_path}: {e}")

    # Optionally remove temporary log and auxiliary files generated by the tool
    if cleanup:
        for f in glob.glob(f"{output_image_path}-log-image_mosaic-*.txt") + glob.glob(f"{output_image_path}.aux.xml"):
            os.remove(f)


def collimation_rectification(
    input_raster_path: str | Path,
    output_raster_path: str | Path,
    qc_dir: str | Path,
    bg_px_threshold: int = 20,
    collimation_line_dist: int = 21770,
    verbose: bool = True,
) -> None:
    """
    Perform collimation rectification on a raster image using Thin Plate Spline (TPS) warping.

    This function detects the horizontal and vertical collimation features in a raster image,
    estimates the geometric deformation, and rectifies the image by applying an inverse
    Thin Plate Spline (TPS) transformation. It also produces several quality control (QC) plots
    illustrating each processing step, including line detection, distance consistency,
    and transformation effects.

    Args:
        input_raster_path (str | Path):
            Path to the input raster image to be rectified.
        output_raster_path (str | Path):
            Path where the geometrically rectified image will be saved.
        qc_dir (str | Path):
            Directory where quality control plots will be stored.
        bg_px_threshold (int, optional):
            Minimum pixel intensity difference used to detect vertical edges. Defaults to 20.
        collimation_line_dist (int, optional):
            Expected distance (in pixels) between the top and bottom collimation lines
            in the rectified image. Defaults to 21770.
        verbose (bool, optional):
            If True, prints progress updates during processing. Defaults to True.

    Returns:
        None

    Workflow:
        1. Detect top and bottom collimation lines using RANSAC polynomial fitting.
        2. Detect left and right vertical edges using robust RANSAC regression.
        3. Estimate and plot the distance between the detected collimation lines.
        4. Compute source and destination TPS control points from detected features.
        5. Apply an inverse TPS transformation to rectify the image geometry.
        6. Re-detect collimation lines after transformation for validation.
        7. Generate and save all QC plots (line detection, distances, gradients).

    Notes:
        - The function assumes that the raster image contains clear collimation marks.
        - All intermediate QC results are saved to `qc_dir` for traceability.
        - The transformation preserves image size consistency using computed `output_size`.
        - The Thin Plate Spline model provides a smooth, non-linear geometric correction.

    Example:
        >>> collimation_rectification(
        ...     input_raster_path="raw_scene.tif",
        ...     output_raster_path="rectified_scene.tif",
        ...     qc_dir="quality_control/",
        ...     bg_px_threshold=25,
        ...     collimation_line_dist=21800,
        ...     verbose=True
        ... )
    """
    # transform to Path every paths
    input_raster_path = Path(input_raster_path)
    output_raster_path = Path(output_raster_path)
    qc_dir = Path(qc_dir)

    if verbose:
        print(f"Collimation rectification for {input_raster_path.name} : ")

    # Detect collimation lines
    if verbose:
        print("\t-[1/4] Estimation of collimation lines...")
    collimation_lines = detect_collimation_lines(
        input_raster_path,
        plot=False,
        output_plot_path=qc_dir / "collimation_lines" / f"{input_raster_path.stem}.png",
    )

    # Detect vertical lines
    if verbose:
        print("\t-[2/4] Detection of vertical lines...")
    vertical_edges = detect_vertical_edges(
        input_raster_path,
        bg_px_threshold,
        plot=False,
        output_plot_path=qc_dir / "vertical_edges" / f"{input_raster_path.stem}.png",
    )

    # make the source and destination points
    src_points, dst_points, output_size = make_tps_points(vertical_edges, collimation_lines, collimation_line_dist)

    # plot them for quality control
    plot_tps_points(
        src_points,
        dst_points,
        output_size,
        plot=False,
        output_plot_path=qc_dir / "transformations" / f"{input_raster_path.stem}.png",
    )

    # create the inverse Thin plate Spline interpolation (dst -> src) using a low-reolution resampling
    inverse_remap_function = make_inverse_tps_function(src_points, dst_points)

    # remap the image with the previously computed function inverse_remap_function
    if verbose:
        print("\t-[3/4] Warping image (can take some times)...")
    remap_tif_blockwise(
        input_raster_path,
        output_raster_path,
        inverse_remap_function,
        output_size,
        block_size=2**13,
        pbar_desc=f"{input_raster_path.name} remapping",
    )

    # detect collimation lines after the transformation
    if verbose:
        print("\t-[4/4] Estimation of collimation lines after transformation...")

    collimation_lines_after_transform = detect_collimation_lines(
        output_raster_path,
        0.02,
        plot=False,
        output_plot_path=qc_dir / "collimation_lines_after_transform" / f"{input_raster_path.stem}.png",
        peaks_strategy="prominence",
    )

    # Plot the distance between collimation lines for quality control
    plot_distance_between_collimation_lines(
        collimation_lines,
        collimation_lines_after_transform,
        output_size[0],
        collimation_line_dist,
        plot=False,
        output_plot_path=qc_dir / "distance_between_collimation_lines" / f"{input_raster_path.stem}.png",
    )

    # plot both collimation gradient before and after transform
    plot_collimation_gradient(
        collimation_lines,
        collimation_lines_after_transform,
        output_size[0],
        plot=False,
        output_plot_path=qc_dir / "collimation_gradients" / f"{input_raster_path.stem}.png",
    )


####################################################################################################################################
#                                                   PRIVATE FUNCTIONS
####################################################################################################################################
