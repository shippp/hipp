"""
Copyright (c) 2025 HIPP developers
Description: core functions for the preprocessing of KH-9 PC images
"""

import glob
import os
import subprocess

import cv2

from hipp.image import apply_clahe, read_image_block_grayscale
from hipp.tools import pick_point_from_image


def image_mosaic(
    image_paths: list[str],
    output_image_path: str,
    overwrite: bool = False,
    threads: int = 0,
    cleanup: bool = True,
    verbose: bool = True,
    dryrun: bool = False,
) -> None:
    """
    Mosaics a list of images into a single output image using the external 'image_mosaic' command.

    Parameters:
        image_paths (list[str]): List of paths to input image tiles.
        output_image_path (str): Path to the output mosaic image.
        overwrite (bool): If False and the output file exists, the function will skip processing. Default is False.
        threads (int): Number of threads to use for processing. Default is 0 (let the tool decide).
        cleanup (bool): Whether to remove temporary log and auxiliary files after processing. Default is True.
        verbose (bool): If True, prints detailed progress and command information. Default is True.
        dryrun (bool): If True, builds the command but does not execute it. Useful for debugging. Default is False.

    Returns:
        None
    """
    # Skip processing if the output exists and overwriting is disabled
    if os.path.exists(output_image_path) and not overwrite:
        if verbose:
            print(f"Skipping {output_image_path}: output already exists")
        return

    if verbose:
        print(f"\nMosaicking {output_image_path} with {len(image_paths)} tiles...\n")

    # Build the command for the external 'image_mosaic' tool
    cmd = [
        "image_mosaic",
        *image_paths,
        "--ot",
        "byte",
        "--overlap-width",
        "3000",
        "--threads",
        str(threads),
        "-o",
        output_image_path,
    ]

    # Display the constructed command
    if verbose:
        print(" ".join(cmd))

    # Execute the command unless in dry run mode
    if not dryrun:
        try:
            subprocess.run(
                cmd,
                check=True,
                stdout=None if verbose else subprocess.DEVNULL,
                stderr=None if verbose else subprocess.DEVNULL,
            )
        except subprocess.CalledProcessError as e:
            print(f"Error while processing {output_image_path}: {e}")

    # Optionally remove temporary log and auxiliary files generated by the tool
    if cleanup:
        for f in glob.glob(f"{output_image_path}-log-image_mosaic-*.txt") + glob.glob(f"{output_image_path}.aux.xml"):
            os.remove(f)


def pick_points_in_corners(
    image_path: str, grid_shape: tuple[int, int] = (5, 20), clahe_enhancement: bool = True, destroy_window: bool = True
) -> dict[str, tuple[int, int]] | None:
    corners_indices = {
        "top_left": (0, 0),
        "top_right": (0, grid_shape[1] - 1),
        "bottom_right": (grid_shape[0] - 1, grid_shape[1] - 1),
        "bottom_left": (grid_shape[0] - 1, 0),
    }
    result = {}
    window_name = "Corner Point Picker"

    for key, indices in corners_indices.items():
        image_bloc, (offset_x, offset_y) = read_image_block_grayscale(image_path, *indices, grid_shape)

        if clahe_enhancement:
            image_bloc = apply_clahe(image_bloc)

        window_title = f"[{os.path.basename(image_path)}] Select {key} with Ctrl + Click"
        point = pick_point_from_image(image_bloc, window_name, window_title)
        if point is None:
            return None
        result[key] = (point[0] + offset_x, point[1] + offset_y)

    if destroy_window:
        cv2.destroyWindow(window_name)
    return result
